#pragma kernel March

#include "Includes/MarchingTables.hlsl"

struct Triangle {
	float3 a, b, c;
};

// Inputs
RWStructuredBuffer<float> weights;
float isoLevel;
uint dimension;

// Output
AppendStructuredBuffer<Triangle> triangles;

int cubicToLinear(int x, int y, int z) {
	return (z * dimension * dimension) + (y * dimension) + x;
}

// Returns a ratio describing how much further w1 is from the isolevel than w2.
// When this number is large, we want to draw lines closer to w2 (the isoLevel
// is closer to w2). This can be used as the scaling factor to bias towards w2.
float scalingFactor(float w1, float w2) {
	return abs(w1 - isoLevel) / (
		abs(w2 - isoLevel) + abs(w1 - isoLevel));
}

// 512 total threads processing one 8x8x8 matrix at a time
[numthreads(8, 8, 8)]
void March(uint3 id: SV_DispatchThreadID) {
	if (id.x > dimension - 1 || id.y > dimension - 1 || id.z > dimension - 1)
		return;

	float cubeWeights[8] = {
		weights[cubicToLinear(id.x,     id.y,     id.z + 1)],
		weights[cubicToLinear(id.x + 1, id.y,     id.z + 1)],
		weights[cubicToLinear(id.x + 1, id.y,     id.z)],
		weights[cubicToLinear(id.x,     id.y,     id.z)],
		weights[cubicToLinear(id.x,     id.y + 1, id.z + 1)],
		weights[cubicToLinear(id.x + 1, id.y + 1, id.z + 1)],
		weights[cubicToLinear(id.x + 1, id.y + 1, id.z)],
		weights[cubicToLinear(id.x,     id.y + 1, id.z)]
	};

	// Calculate the lookup table index. The index is synonymous with
	// the precise configuration of points above and below the
	// isoLevel and identifies what triangles to draw.
	uint index = 0;
	if (cubeWeights[0] > isoLevel) index |= 1;
	if (cubeWeights[1] > isoLevel) index |= 2;
	if (cubeWeights[2] > isoLevel) index |= 4;
	if (cubeWeights[3] > isoLevel) index |= 8;
	if (cubeWeights[4] > isoLevel) index |= 16;
	if (cubeWeights[5] > isoLevel) index |= 32;
	if (cubeWeights[6] > isoLevel) index |= 64;
	if (cubeWeights[7] > isoLevel) index |= 128;

	// The triangles we need to draw have their vertices along these
	// edges of the cube. We pick a point via linear interpolation.
	int edges[] = trianglesTable[index];
	for (uint i = 0; edges[i] != -1; i += 3)
	{
		int e1[] = edgesTable[edges[i]];
		int e2[] = edgesTable[edges[i + 1]];
		int e3[] = edgesTable[edges[i + 2]];
		float3 one = float3(1.0, 1.0, 1.0);

		Triangle tri;
		tri.a = id + lerp(
			verticesTable[e1[0]],
			verticesTable[e1[1]],
			one * scalingFactor(cubeWeights[e1[0]], cubeWeights[e1[1]]));
		tri.b = id + lerp(
			verticesTable[e2[0]],
			verticesTable[e2[1]],
			one * scalingFactor(cubeWeights[e2[0]], cubeWeights[e2[1]]));
		tri.c = id + lerp(
			verticesTable[e3[0]],
			verticesTable[e3[1]],
			one * scalingFactor(cubeWeights[e3[0]], cubeWeights[e3[1]]));
		triangles.Append(tri);
	}
}
